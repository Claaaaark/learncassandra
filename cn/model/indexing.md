# 索引

<sup>[1](#ref_1)</sup>Cassandra的索引(index，又称secondary index)支持通过非主键字段查询数据的能力。事实上，如果没有为一个普通字段建索引，Cassandra是完全不支持按这个字段值做任何条件查询的。

一个索引的数据，保存在一个隐藏的column family中。一个节点上索引，只包含对当前节点存在的本地数据的索引，也就是说，索引数据是不会被replicate到其他节点的。同时，这也意味着，按索引字段进行查询，查询请求需要被转发到所有的节点，并返回合并的查询结果。所以，节点越多，索引查询会更慢。

**注意：**

直到当前版本（2.0.7）的Apache Cassandra，对于索引字段的条件查询只支持相等比较。不支持对于索引字段的范围查询和字段排序。主要的原因是，保存索引数据的隐藏column family的主键是无序存储的。

## 何时使用索引？

<sup>[2](#ref_2)</sup>Cassandra的索引功能最适合，很多行包含相同的被索引列的值的情形。某一个字段的值，对于所有的行来说，越唯一，索引查询的性能和维护成本就越差。例如：假设有一个播放列表表，包含100万首歌，并且需要按歌手字段查询。因为每个歌手会有很多歌，歌手这个字段，就适合创建索引。

## 何时不要使用索引？

<sup>[2](#ref_2)</sup>下面这些情形不要使用索引：
* 字段的只对所有的行来说非常唯一，比如时间字段
* 包含counte类型字段的表
* 频繁更新和删除的表
* 在超大分区查询得到很少行的数据（除非先按照其他条件缩小查询范围）

## 参考

1. <a name="ref_1"></a>http://www.datastax.com/documentation/cql/3.1/cql/ddl/ddl_primary_index_c.html
2. <a name="ref_2"></a>http://www.datastax.com/documentation/cql/3.1/cql/ddl/ddl_when_use_index_c.html
